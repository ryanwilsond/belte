$BU0000
If you see this error code, that means that there was a fatal error in the
compiler that prevented it from completing compilation. This is NOT a user
error, but rather a bug that should be reported. Currently, the best way to
report bugs is directly on the issues tab on GitHub.

If the problem is preventing further development, try downgrading Buckle to the
previous stable patch version. If the problem persists, make sure to create an
issue on GitHub (though we at Belte Industries would appreciate an issue
report nonetheless).

You can use the following link to create an issue:
https://github.com/ryanwilsond/belte/issues/new?assignees=&labels=&template=bug_report.md&title=
$BU0001
The compiler produces this warning if it can tell that an expression will always
result in the same value. Not all expressions that have a constant value will be
found by the compiler, but most simple ones will.

For example:

```
if (2 > 0) { } // 2 > 0 is always true, so this warning is produced
```
$BU0002
The compiler produces this warning if it detected that a value may be null
during a deference/member accession. Note that the compiler cannot catch every
null deference case, especially relating to called code where code analysis is
not possible. You can prevent this warning by using the null assert (`!`)
operator.

For example:

```
class MyClass {
    int myMember;
}

void MyFunction(MyClass myParameter) {
    myParameter.myMember = 3; // Warning is produced here
    myParameter!.myMember = 3; // But not here
}
```
$BU0003
The compiler produces this error when it either ca not find a reference, or it is
the wrong file type. This usually means that a reference specified on the command
line is in a different location.

For example:

```
$ buckle --ref=some/fake/reference.dll // Correct format, but does not exist
```
$BU0004
When the compiler fails to parse a literal it produces this error. Currently,
this error will only come up in place of runtime overflow or underflow
exceptions.

For example:

```
int myInt = 9999999999; // Exceeds integer limit, cannot parse
```
$BU0005
When the compiler is given an unknown character when scanning the input files,
it produces this error. Thus this is a user syntax error.

For example:

```
@ // The compiler does not currently handle this character
```
$BU0006
When the compiler expects a certain piece of text and does not find it, this
error is produced. This error comes in three forms:

- Unexpected token
- Unexpected token, expected another token instead
- Expected a token at the end of the input

In all of these cases, if this error is raised the user made a syntax error.

For example:
```
if (true { } // The compiler expected a closing parenthesis before the open bracket
```
$BU0007
Some casts are implied, but others must be explicitly specified. When an
explicit cast is not specified explicitly, this error is produced.

For example:

```
decimal myDecimal = 4; // Implicit cast from integer to decimal, allowed
int myInt = 3.4; // Explicit cast from decimal to integer, produces this error
```

When possible the compiler will suggest how to make the cast explicit. If no
explicit cast is possible either, error BU0020 is used instead.
$BU0008
When a unary operator is used with unsupported types, this error is produced.

For example:

```
int myInt = ~4; // `~` is allowed with integer types
decimal myDecimal = ~3.4; // But not for decimal types
```

A possible fix to this error may be inserting a cast.
$BU0009
When calling a method, some arguments can reference parameters by name instead
of by ordinal. However, all arguments referencing by name must come after any
arguments referencing by ordinal. This is not because the compiler cannot figure
out the intention, but rather it makes confusing code and is bad practice.

For example:

```
void MyFunction(int x, int y) { }

MyFunction(x: 1, 2); // Named argument before unnamed argument, not allowed
MyFunction(1, y: 2); // Allowed
```
$BU0010
When calling a method, some arguments can reference parameters by name instead
of by ordinal. However, similar to naming parameters, each name can only be used
once to prevent ambiguity between parameters.

For example:

```
void MyFunction(int x, int y) { }

MyFunction(1, y: 2, y: 3); // `y` specified twice, not allowed
MyFunction(1, y: 2) // Allowed
```
$BU0011
When a binary operator is used with unsupported types, this error is produced.

For example:

```
int myInt = 3 + 4; // `+` is allowed with two integers
bool myBool = true + 3; // But not for a boolean and an integer
```

A possible fix to this error may be inserting a cast.
$BU0012
Without a `Main` method, the compiler will run files top-down. However when
compiling multiple files, it becomes ambiguous which file to run first.
Because of this, only one file can contain global statements.

If this becomes a problem, consider reworking your project to use an explicit
entry point such as `Main`.
$BU0013
When a method is declared with multiple parameters of the same name, it
becomes ambiguous when referencing parameters. Because of this, each parameter
must have a unique name, even if they are different types. This also makes the
code easier to read inside the method body.

For example:

```
void MyFunction(int myParam, bool myParam) { } // Not allowed because both parameters have the same name
```
$BU0014
`Main` can only return void or an integer. If a `Main` method is declared
with any other return type this error is produced.

For example:

```
string Main() {
    return "Hello, world!";
} // `Main` cannot return strings
```

This is a callback to how older languages like C handle their entry points with
the command line. If you are making a library with no entry point, this error
will not come up.
$BU0016
When a `Main` method is not declared, files are run top-down. However if a
`Main` method is declared, global statements are not allowed as it becomes
ambiguous about where to start execution.

For example:

```
PrintLine("Hello, world!"); // Not allowed, because `Main` is where execution starts

void Main() { }
```
$BU0017
When a symbol is referenced and it cannot be found, the compiler produces this
error. This is most likely the result of a typo or scoping issue.

For example:

```
int myInt = 3 + myOtherInt; // `myOtherInt` was never declared, so this is not allowed
```
$BU0018
Methods in the same scope have to have unique names (unless you are
overloading). When an attempt is made to declare a method with a name already
used (and the parameter list is the same), the compiler produces this error.
This is to make sure there is no ambiguity when calling methods. Other
overload-related errors such as BU0057 and BU0058 will be used with overloaded
methods instead.

For example:

```
void MyFunction() { } // `MyFunction` has not been declared in this scope, allowed

void MyFunction() { } // `MyFunction` has already been declared, not allowed
```
$BU0019
To prevent undefined behavior, all methods must return in all scenarios if
they have a non-void return type. The compiler checks this and raises an error
if any code path does not return.

For example:

```
int MyFunction(int myParam) {
    if (myParam > 3)
        return myParam + 1;
    // If `myParam` is not greater than 3 this method does not return, not allowed
}
```

The compiler uses graph analysis on the code to figure out what paths do not
return. If you believe there is an issue, report one:
https://github.com/ryanwilsond/belte/issues/new?assignees=&labels=&template=bug_report.md&title=
$BU0020
If a cast is not specified between two types, the compiler produces this error.

For example:

```
int[] myCollection = (int[])"test"; // Cannot cast from string to integer collection
```

User-defined types must create their own casting rules.
$BU0021
Variables in the same scope have to have unique names. When an attempt is made
to declare a variable with a name already used, the compiler produces this
error. This is to make sure there is no ambiguity when referencing variables.

For example:

```
int myVar; // `myVar` has not been declared in this scope, allowed
int myVar; // `myVar` has already been declared, not allowed
```

However, if they are in separate scopes this is allowed.

For example:

```
int myVar;

void MyFunction() {
    int myVar; // `myVar` has not been declared in this scope, allowed
}
```

In this case, the most nested declaration gets priority in the most nested
scope. If `myVar` was referenced in `MyFunction` it would not use the outer
declaration, but rather the one nested inside `MyFunction`. This applies even if
the variables have different types. This is referred to as shadowing and is not
always allowed in nested block statements.
$BU0022
Constants can only be defined once when they are declared. This means that you
cannot change their value after their initial definition. When an attempt is
made to redefine a constant, the compiler produces this error.

For example:

```
const int myConst = 4; // Initial definition, allowed and required
myConst = 5; // Redefinition, not allowed
```
$BU0023
Because of the way if-statements are parsed, they can become ambiguous. The
compiler produces this error to try and prevent some ambiguity.

For example:

```
if (true)
    if (true) ;
    else ;
```

This could be written as:

```
if (true)
    if (true) ;
else ;
```

Because whitespace is ignored by the compiler, these do the same thing. However,
they appear like they should execute differently from each other. In the first
example, the else clause seems to belong to the inner if-statement, however, in
the second example, it seems to belong to the outer if-statement.

Whenever there is an if-statement that contains an if-statement instead of a
block-statement for its body, and the inner if-statement has an else-clause
without using blocks, the compiler produces this error.
$BU0024
Expressions resulting in no value by using `void` cannot be put in place of
expressions expecting a value.

For example:

```
void MyFunction() { }

int myInt = MyFunction(); // `MyFunction` has no return value, and an initializer must have a value or be `null`
```
$BU0025
Indexing allows retrieving elements from a collection. However, indexing is only
allowed on collection types or user-defined types that support explicitly
support it. The compiler produces this error when indexing is used on any other
type.

For example:

```
int[] myCollection = {1, 2, 3};
int myInt = myCollection[2]; // `myCollection` is a collection type, so this is allowed
int mySecondInt = myInt[1]; // `myInt` is not a collection type, so this is not allowed
```
$BU0026
When the compiler detects unreachable code, it will produce this warning. This
is not an error because the compiler will continue the compilation process,
removing the unreachable code from the assembly.

For example:

```
if (true) {
    int myInt = 2;
} else {
    int myInt = 3; // True is always true, so this else-clause can never execute
}
```

It is usually bad practice to have unreachable code, but it is allowed as in
some cases it is helpful temporarily.
$BU0027
Every string is started with a double quote and ended the same way. If the
ending quote is missing, the compiler does not know when the string ends. In
that case, this error is produced.

For example:

```
string myString = "Hello, world!
int myInt = 2; // The string was never terminated, so an error is produced
```

This error assumes that multi-line strings are not allowed, and they are not
currently.
$BU0028
A method must have a declaration, so when a method without a declaration is
called, the compiler does not know what method is being referenced. In this
case, the compiler produces this error.

For example:

```
int myInt = MyFunction(); // `MyFunction` does not exist in this scope, not allowed
```

This error is usually temporary when implementing new methods, or the result
of a typo or scoping issue.
$BU0029
When calling a method, there must be the correct number of arguments provided
so the method can safely assume it can use the data it requests. If the number
of arguments provided in a method call does not match the method signature,
this error is raised.

For example:

```
int Add(int a, int b) {
    return a + b;
}

Add(1, 2, 3); // Too many arguments, incorrect
Add(1); // Too few arguments, incorrect
Add(1, 2); // Correct
```

This only applies to required parameters. Optional parameters are optional, and
missing them would not raise this error. If there is a required parameter that
you do not want to pass, you can pass null (assuming it is a nullable
parameter), or use the shorthand implicit null argument syntax:

```
Add(1,);
// Would be the same as
Add(1, null);
```

Or even:

```
Add(,2);
// Would be the same as
Add(null, 2);
```
$BU0030
Similar to methods, variables, fields, and constants, class and structure types
cannot have more than one definition in a single scope. This is so there is no
ambiguity when referencing a type.

For example:

```
class MyClass { // First definition, allowed
    int myMember;
}

class MyClass { // `MyClass` was already defined, not allowed
    bool myOtherMember;
}
```

Even though the two definitions are different, they use the same identifier so
the second one is marked as an error.
$BU0031
When applying attributes to a type, you can specify any number of them. If there
are duplicate attributes, however, the compiler will raise this error. Even
though the compiler could figure out the intended meaning, it would be poorly
written code and possibly a mistake or oversight. Because of this, the compiler
does not allow duplicate attributes.

Example here will be updated, but currently there are not attributes.
$BU0032
Only methods, functions, and constructors are called objects. This is because
they have a body that can be run. Variables, constants, and other similar
objects only store data, they do not act on that data themselves. Hence, they
cannot be called as a method can. If it is attempted to call a variable,
field, constant, or indexer this error is raised.

For example:

```
void MyFunction() { }

int myInt = 3;

MyFunction(); // `MyFunction` is a method, allowed

myInt(); // `myInt` is a variable (cannot be called), not allowed
```
$BU0033
In a programming language, there are multiple grammatical components, such as
statements and expressions. Statements represent a complete thought, while
expressions only carry out a singular action. Some examples of statements are if
statements, try statements, block statements, etc. Some examples of expressions
are assignment expressions, variable declaration expressions, binary
expressions, etc.

Some expressions can be used as statements, such as assignment expressions.
When these expressions are used as statements, they are expression statements.

For example:

```
int myInt = 3; // This is an expression statement
myInt = 5; // This is an expression statement
```

Not all expressions can be used as statements, however. If an expression that
cannot be used as a statement is attempted to be used as a statement this error
is raised.

For example:

```
int myInt = 3; // This is an allowed expression statement
4 + 7; // This is not an allowed expression statement
```

For a full list of allowed expression statements, visit the Belte documentation.
$BU0034
Belte is a statically typed language, so all variables, parameters, etc. need
a type associated with them at compile time. If a type is used that the compiler
is unaware of, this error is raised.

For example:

```
int myInt; // `int` is a known type, allowed
char myChar; // `char` is NOT a known type, not allowed
```
$BU0035
Break and continue statements are used to manipulate the running of a loop. That
is their only purpose, thus outside of a loop, they are invalid. This error is
raised if a break or continue statement is used outside of a loop.

For example:

```
while (true) {
    break; // Inside a while loop, allowed
}

break; // Not inside any loop, not allowed
```
$BU0036
Return statements are used to exit from a function or method. That is their only
purpose, in addition to returning values. Outside of a function or method,
return statements are invalid. This error is raised if a return statement is
used outside of a function or method.

For example:

```
int Main() {
    return 3; // Inside of a method, allowed
}

return 4; // Outside of a function or method, not allowed
```

The only exception to this rule is when a file is being run with global
statements. In that case, the return signals the end of the entire program.
$BU0037
Some methods are procedures, methods that do not return a value. In Belte
this is indicated by replacing the return type of a method with the `void`
keyword. If it is attempted to return a value in a void method, this error is
raised.

For example:

```
void MyFunction() {
    return; // Normal return in void method, allowed
}

void MyOtherFunction() {
    return 3; // Returning a value in a void method, not allowed
}
```
$BU0038
Some methods return values. If a method is indicated to return a value, it
must always return a value (or lack thereof using `null`). If a return statement
is used without a value in one of these methods, this error is raised.

For example:

```
int MyFunction() {
    return 1; // Returning a value when expected, allowed
}

int MyOtherFunction() {
    return; // Not returning a value when a value is expected, not allowed
}
```
$BU0039
Functions, methods, and constructors are callable objects. If one of these it
attempted to be used as a variable, this error is raised.

For example:

```
void MyFunction() { }

MyFunction(); // Calling a method, allowed

MyFunction = 3; // Treating a method as a variable, not allowed
```

This error is fairly general and will be raised in any expression attempting
to use a method as a variable, including (but not limited to): binary, unary,
postfix, prefix, index, and assignment expressions.
$BU0040
In Belte, you can have the compiler guess the type of a variable by replacing
any type with the `var` keyword. (Note: this only applies to variables, not
parameters, return types, etc.) Because the compiler uses the declaration
initializer to guess the variable type, it is required to have an initializer
when using the `var` keyword. Otherwise, this error is raised.

For example:

```
var myInt = 3; // The compiler can figure out that `myInt` is an integer by the initializer, allowed
var myString; // The compiler has nothing to base the type on, not allowed
```

In dynamically typed languages this would probably be allowed, but because Belte
is statically typed it must know the type immediately, so this is not allowed.

The only solution to this error is to explicitly list the type of the variable,
as then the initializer is not required.
$BU0041
Similar to strings, multi-line comments must be terminated at some point. If
they are not, this error is raised.

For example:

```
/*
My comment text
*/ // The comment is terminated, allowed

/*
My comment text
// The comment is never terminated, not allowed
```

Note that comments using `//` are single-line, and are terminated automatically
at the end of the line.

Note that it is almost impossible to miss this syntax error with syntax highlighting, as
it would render the entire source file as a comment.
$BU0042
In Belte, you can have the compiler guess the type of a variable by replacing
any type with the `var` keyword. (Note: this only applies to variables, not
parameters, return types, etc.) Because the compiler uses the declaration
initializer to guess the variable type, it is required to have an initializer
when using the `var` keyword.

If the initializer is missing completely, error BU0040 is raised. If the
initializer is the `null` keyword, this error is raised. This is because
initializing an implicitly typed variable with `null` faces the same problem as
no initializer completely, as `null` is not specific to a single type.

For example:

```
var myInt = 3; // The compiler can figure out that `myInt` is an integer by the initializer, allowed
var myString = null; // Even though it is initialized, the compiler still has nothing to base the type on, not allowed
```

The only solution to this error is to explicitly list the type of the variable,
as then the initializer is not required at all, so `null` can be used to
initialize it.

Note that a variable successfully declared without an initializer will default
to `null`:

```
int myInt;
// Is the same as
int myInt = null;
```
$BU0043
In Belte, you can have the compiler guess the type of a variable by replacing
any type with the `var` keyword. (Note: this only applies to variables, not
parameters, return types, etc.) Because the compiler uses the declaration
initializer to guess the variable type, it is required to have an initializer
when using the `var` keyword.

If the initializer is missing completely, error BU0040 is raised. If the
initializer is an empty initializer list (such as `{}`), this error is raised.
This is because initializing an implicitly typed variable with `{}` faces the
same problem as no initializer completely, as `{}` is not specific to a single
type.

For example:

```
var myCollection = {1, 2, 3}; // The compiler can figure out that `myCollection` is a collection of integers by the initializer, allowed
var myCollection = {}; // Even though it is initialized, the compiler still has nothing to base the type on, not allowed
```

In the given example, the compiler can not be sure what type of collection the
user is inferring. It could be `int[]`, `string[]`, or `bool[]` for all the
compiler knows.
$BU0044
Unlike C#, in Belte the `var` keyword does not only infer the base type name,
but instead, it infers the entire type, apart from the `const` keyword.

For example:

```
var[] myCollection = {1, 2, 3}; // Not allowed, as the compiler can infer the `[]` so it is not needed
var myCollection = {1, 2, 3}; // Allowed
```
$BU0045
The `var` keyword/implicit typing cannot be used in every context. Types
relating to a signature or field declarations need to be explicit as they never
have initializers, so the compiler would not know what types there are.

For example:

```
void MyFunction(var myParameter) { } // The compiler has no information on what the type of `myParameter` is, not allowed
```

Another example:

```
class MyClass {
    var myMember; // The compiler has no information on what the type of `myMember` is, not allowed
}
```

Implicit typing is only allowed for variable or constant declarations.
$BU0046
A try statement must have a catch or finally clause accompanying it. This is
because a try statement without a catch or finally would be no different then
a block statement, as the try block itself, does nothing, rather it is the catch
and finally clauses that handle the exceptions thrown.

For example:

```
try {
    int myVar = 5 / 0;
} // Not allowed, no catch or finally block

try {
    int myVar = 5 / 0;
} catch {
    PrintLine("DIVIDE BY ZERO");
} // Allowed

try {
    int myVar = 5 / 0;
} finally {
    PrintLine("Program is exiting");
} // Also allowed
```

Note that having both a catch and a finally clause is also allowed.
$BU0047
Static classes are classes containing only static members. They have no
constructors because they are never initialized. If an instance member is
declared in a static class, this error is raised.

For example:

```
static class MyClass {
    void MyMethod() { } // Not allowed, `MyMethod` is not static
    static void MyMethod() { } // Allowed
}
```
$BU0048
By-reference variables always reference other variables. Because of this, they
themselves cannot be null and require an initializer. If a by-reference
variable is declared with no initializer, this error is raised.

For example:

```
ref int myRef; // Incorrect, does not reference anything

int myVar = 3;
ref int myRef = ref myVar; // Correct, references `myVar`
```
$BU0049
By-reference variables can be assigned to with values, which are just passed on
to what it is referencing. However, the declaration initializer must be a
reference as there is nothing to pass on to yet. If a by-reference variable is
declared with a by-value initializer, this error is raised.

For example:

```
ref int myRef = 3; // Incorrect, `myRef` does not reference anything yet so it cannot pass `3` onto its reference

int myVar = 3;
ref int myRef = ref myVar; // Correct, references `myVar`; future by-value assignments are now allowed
```

Note that the reference must be explicit:

```
int myVar = 3;
ref int myRef = ref myVar;
ref int myOtherRef = myRef; // Not allowed, this would pass the value of `myVar` which is by-value, not by-reference
```
$BU0050
By-value variables cannot be assigned to by an explicit reference expression.
They can be assigned to by variables that are references, and in that case, the
value that the by-reference variable is referencing is passed. If a by-value
variable is assigned to by an explicit reference expression, this error is
raised.

For example:

```
int myVar = 3;
int myOtherVar = ref myVar; // Incorrect, `myOtherVar` is by-value and cannot be assigned with a reference
```

Note that this only applies to explicit references, and a reference variable can
be the assignee:

```
int myVar = 3;
ref int myRef = ref myVar;
int myOtherVar = myRef; // Allowed, this would pass the value of `myVar` as that is what `myRef` is referencing
```
$BU0051
Attributes can be applied to types, and users can define their own attributes.
However, if the compiler is unaware of an attribute, this error is raised.

Example here will be updated, but currently there are not attributes.
$BU0052
Some types are non-nullable, even though the default is nullable. If a variable
or constant is non-nullable, it cannot be assigned with `null`. If this is
attempted, this error is raised.

For example:

```
int! myVar = null; // Not allowed, `myVar` is non-nullable, so it cannot be assigned to with `null`
```
$BU0053
Unlike C#, in Belte the `var` keyword does not only infer the base type name,
but instead, it infers the entire type, apart from the `const` keyword.

For example:

```
int myInt = 3;
ref var myRef = ref myInt; // Not allowed, as the compiler can infer the `ref` keyword so it is not needed
var myRef = ref myInt; // Allowed
```
$BU0054
By-reference variables can either be referencing a constant or a variable. These
are not interchangeable.

For example:

```
const int myConst = 3;
ref int myRef = ref myConst; // Not allowed, as `myRef` expects a reference to a variable, not a reference to a constant
```

This is an error because if this were allowed, constants could be modified
indirectly through references at runtime. This makes constants not different
than variables.

To highlight this point more clearly, take the example:

```
const int myConst = 3;
ref int myRef = ref myConst;
myRef = 4; // `myConst` is indirectly modified, now equalling `4`
```

The following is allowed:

```
const int myConst = 3;
ref const int myRef = ref myConst;
```

`myRef` can be assigned, to change what it is referencing, but it cannot
change the value of what it is referencing at any time.

The following could be used if a variable reference is wanted:

```
int myInt = 3;
ref int myRef = ref myInt;
```
$BU0055
Void is used to denote that a method is a procedure. If void is used in most
other scenarios, the compiler produces this error. This is because `void` is NOT
a type, but rather an indicator that nothing will be returned.

For example:

```
void MyFunction() { } // Allowed

void myVar; // Not allowed, `void` cannot be used as a type
```
#BU0056
If a specific type of syntax is expected in an expression or statement, many
errors could be raised, depending on what gives the most information in any
context. If an incorrect piece of syntax is found, errors such as BU0006 will be
raised, but if a piece of syntax is purely missing, this error is raised.

For example:

```
class { // An identifier is expected before the opening curly brace to identify the class
    int myMember;
}
```

Another example:

```
void () { } // An identifier is expected before the opening parenthesis to identify the method
```
$BU0057
Error BU0029 is used if a method call has the wrong number of arguments. This
error is raised in place of that one if the method being called has overloads.

For example:

```
void MyFunction(int a) { }

void MyFunction(string a) { }

MyFunction(1, 3); // No overload matches this parameter list, incorrect
```

The reason the error is different is that the argument count can be correct,
but the types can be incorrect. A casting error cannot be raised because since
there are overloads, the compiler cannot tell the exact casting errors.
$BU0058
Sometimes a method call can be ambiguous between multiple overloads,
especially when the arguments are `null`. If the compiler cannot tell which
overload to use in a call expression, this error is raised.

For example:

```
void MyFunction(int a) { }

void MyFunction(string a) { }

MyFunction(null); // Ambiguous which overload is being inferred, as `null` could be either an integer or string
```
$BU0059
Increment and decrement expressions modify the operand. Because this is the
case, the operand must be modifiable/assignable. If it is attempted to
increment or decrement a nonassignable operand this error is raised.

For example:

```
1++; // Now allowed, `1` is not an assignable operand
int a = 3;
a++; // Allowed, `a` is assignable
```

This also applies to the prefix version of these operators:

```
++1; // Now allowed, `1` is not an assignable operand
int a = 3;
++a; // Allowed, `a` is assignable
```

And also applies to their decrement counterparts.

Only variables, fields, and indexers can be assigned to.
$BU0060
When a ternary operator is used with unsupported types, this error is produced.

For example:

```
int myInt = true ? 3 : 4; // `?:` is allowed with one boolean and two integers
bool myBool = 3 ? true : false; // But not with an integer and two booleans
```

A possible fix to this error may be inserting a cast.
$BU0061
When a nonexistent member is attempted to be accessed with a member access
expression, this error is raised.

For example:

```
class MyClass {
    int a;
}

MyClass myVar = new MyClass();
int myInt = myVar.b; // `b` is not a member of the `MyClass` type
```

Another example:

```
class MyClass {
    int myMember;
}

MyClass myClass = MyStruct();
int myInt = myStruct.myOtherMember; // `myOtherMember` is not a member of the user-defined `MyStruct` type
```

A full list of all the members of built-in types can be found in the Belte
documentation.
$BU0062
Not every expression can be assigned to. If an assignment expression is
attempted where the left side cannot be assigned to, this error is raised.

For example:

```
5 = 4; // You cannot assign to literal expressions
PrintLine() = 4; // You cannot assign to call expressions
```

You can only assign to variables, fields, and indexers. Any other left side
expression will result in this error.

Note that if the failure to assign is because the left side is a constant,
BU0022 is raised instead.
$BU0063
Nested/inner functions cannot be overloaded. If it is attempted to overload
a nested function, this error is raised.

For example:

```
void MyFunction() {
    void MyNestedFunction() { }

    void MyNestedFunction(int myParameter) { } // Overloads are not allowed, so this is seen as a duplicate definition which is not allowed
}
```

If you need to overload a nested function, you should probably be using methods
anyway.
$BU0064
By-reference variables can either be referencing a constant or a variable. These
are not interchangeable.

For example:

```
int myInt = 3;
ref const int myRef = ref myInt; // Not allowed, as `myRef` expects a reference to a constant, not a reference to a variable
```

This is an error because if this were allowed, code using the reference would
be under the false assumption that the value will not change. The value could
change indirectly if the variable the by-reference variable is referencing
changes during runtime.

To highlight this point more clearly, take the example:

```
int myInt = 3;
ref const int myRef = ref myInt;
myInt = 4; // `myInt` is modified, indirectly modifying `myRef` to be referencing a changed value
```

The following is allowed:

```
const int myConst = 3;
ref const int myRef = ref myConst;
```

`myRef` can be assigned to, to change what it is referencing, but it cannot
change the value of what it is referencing at any time.

The following could be used if a variable reference is wanted:

```
int myInt = 3;
ref int myRef = ref myInt;
```
$BU0065
When a prefix operator is used with unsupported types, this error is produced.

For example:

```
int myInt = 2;
++myInt; // `++` is allowed with integer types

bool myBool = false;
++myBool; // But not for decimal types
```

A possible fix to this error may be inserting a cast.
$BU0066
When a postfix operator is used with unsupported types, this error is produced.

For example:

```
int myInt = 2;
myInt++; // `++` is allowed with integer types

bool myBool = false;
myBool++; // But not for decimal types
```

A possible fix to this error may be inserting a cast.
$BU0067
When using an argument that references a parameter by name and the parameter has
already been referenced by position, this error is thrown.

For example:

```
void MyFunction(int x, int y) { }

MyFunction(1, x: 2); // `x` was already specified by position by the first argument, so it is a duplicate; not allowed
MyFunction(1, 2); // Allowed
```
$BU0068
When creating an optional parameter while declaring a method, the default
value must be a compile-time constant, as in it needs to be computable during
compilation. This is so the compiler can accurately place the default value
when the optional parameter is not specified during a call expression whilst
preventing side effects.

For example:

```
void MyFunction(string x = Input()); // `Input()` requires input from the user, so it is not constant and the compile cannot compute it; not allowed
void MyFunction(string x = "Test"); // `"Test"` is constant; allowed
```
$BU0069
Because optional parameters do not need to be specified, but required ones do,
all required parameters must come before any optional parameters. This is
because intermixing the two while referencing parameters by position would
require the user to specify optional parameters to reach the required ones,
making them not optional.

For example:

```
void MyFunction(int x, int y = 3, int z); // To get to the required parameter `z` by position, the user would have to specify `y` making it required; not allowed
void MyFunction(int x, int y, int z = 3); // Allowed
```
$BU0070
There are two broad types of storage containers in Belte: variables and
constants. Variables can be changed, while constants cannot (hence the names).
Because of this, you cannot mark a type as both variable and constant.

For example:

```
const var myInt = 3; // Not allowed, marked constant and variable at the same time
const myInt = 3; // Allowed
var myInt = 3; // Allowed
```
$BU0071
Types, variables, fields, and constants all share the same naming rules. Because
of this, it can be ambiguous whether the user is referring to a variable versus
a type for example.

For example:

```
class A { }

A A = new A(); // Not allowed, variable name `A` will cause confusion
A a = new A(); // Allowed
```

This prevents ambiguous statements like:

```
class A {
    static void F() { }

    void F() { }
}

A A = new A();
A.F(); // Is this referring to the static method or the instance method?
```

In this case, it would always refer to the instance method, but reading this as
a developer it is easily confusing. This is why this is not allowed.

This error will only apply to types in the same namespace as the variable
declaration so that other namespaces do not interfere with naming.
$BU0072
You can implicitly pass null in multiple contexts such as call expressions by
omitting any value before or after a comma. However, if you attempt to pass null
this way when a non-nullable type is expected, this error is raised.

For example:

```
void MyFunction(int a, int! b) { }

MyFunction(, 2); // Allowed, the first parameter is nullable
MyFunction(1,); // Not allowed, the second parameter is non-nullable
MyFunction(,); // Not allowed, while the first parameter is nullable, the second parameter is not
```
$BU0073
When a cast does not exist purely because you are trying to cast a null literal
to a non-nullable type, this error is raised in place of BU0020.

For example:

```
var myDecimal = (decimal!)true; // Not allowed, BU0020 is raised as you cannot convert from bool to decimal
var myDecimal = (decimal!)null; // Not allowed, this error is raised as you cannot `null` to a non-nullable type
```
$BU0074
Modifiers such as `const` and `static` effect the meaning of a member. Each
modifier can only be applied once per item.

For example:

```
class MyClass {
    const const int myField = 3; // Not allowed, `const` modifier applied twice
    const int myField = 3; // Allowed
}
```
$BU0075
The `ref` keyword cannot be used in every context. Types relating to field
declarations cannot be defined when declaring them, meaning you cannot assign
a reference.

For example:

```
class MyClass {
    ref int a; // Not allowed, cannot define so using `ref` here is not allowed
    int a; // Allowed
}
```
$BU0076
Dividing by zero is a defined operation, thus it is not allowed. When the
compiler can detect code that will divide by zero, this error is raised.

For example:

```
int myInt = 5 / 0; // Not allowed, attempting to divide by zero
```
$BU0077
To prevent ambiguity, if a name is used inside the closest enclosing method
scope that name is reserved and cannot be used inside nested non-method
scopes (such as for loops).

For example:

```
void MyFunc() {
    for (int i = 0; i < 5; i++) ; // Not allowed, `i` is used later to declare a local

    int i = 1;
}
```

Because this only applies to non-method scopes, the following is allowed:

```
void MyFunc() {
    int i = 1;

    void MyNestedFunc() {
        int i = 5;
    }
}
```

This only applies to non-method scopes because method scopes shadow, whilst
other blocks and bodies do not.
$BU0078
When implicitly initializing a variable or constant, you cannot use an
initializer list only containing `null`. This is because `null` can be used for
most types, so the compiler cannot figure out the type based on only `null`.

For example:

```
var myArray = { null, null }; // Not allowed, the compiler cannot deduce the type of the variable
var myArray = { null, 3 }; // Allowed, the compiler can use the non-null value to deduce the type of the variable
```
$BU0079
If the compiler does not recognize an escape sequence, this error is raised.

For example:

```
var myString = "test\g"; // Not allowed, `\g` is not a known escape sequence
var myString = "test\n"; // Allowed
```

Refer to the Belte documentation for a list of accepted escape sequences.
$BU0080
Primitive types in Belte are pure data and no state. This means they have no
members and do not inherit from Object. If a member is attempted to be accessed
off of a primitive, this error is raised.

For example:

```
int myInt = 3;
string myString = myInt.ToString(); // Not allowed, primitive types have no members
```
$BU0081
Primitive types (such as `int`) cannot be created using the `new` keyword,
because they have not constructors.

For example:

```
int myInt = new int(); // Not allowed, `int` is a primitive and thus cannot have any constructors
int myInt = 3; // All primitives are created through literals, such as `3`
```
$BU0082
If a template has multiple overloads but the given template arguments do not
match any of the overloads (even with implicit casting) this error is raised.

For example:

```
class MyClass<int T> { }

class MyClass<bool T> { }

var myClass = new MyClass<3.5, false>(); // No overload matches this parameter list, incorrect
```
$BU0083
Sometimes a list of template arguments can be ambiguous between multiple
overloads, especially when the arguments are `null`. If the compiler cannot tell
which overload to use in an object creation expression, this error is raised.

For example:

```
class MyClass<int T> { }

class MyClass<bool T> { }

var myClass = new MyClass<null>(); // Ambiguous which overload is being inferred, as `null` could be either an integer or boolean
```
$BU0084
Outside of a low-level context structs are disabled, along with several other
lower level features.
$BU0085
The `this` keyword is used to access type members, such as fields and methods.
It searches for members of the currently enclosing type, so if this keyword is
used outside of a type definition, this error is raised.

For example:

```
int myInt = 3;
int myOtherInt = this.myInt; // Not allowed, not inside of a type definition

class MyClass {
    int myInt;

    void MyMethod() {
        this.myInt = 3;
        int myOtherInt = this.myInt; // Allowed
    }
}
```
$BU0086
Constructors are methods that are run when an object is created, and the name
of a constructor must match the class name. Otherwise this error is raised.

For example:

```
class MyClass {
    MyConstructor() { } // Not allowed, all constructors must be named the same as the class name, in this case `MyClass`

    MyClass() { } // Allowed
}
$BU0087
If an object is created with an argument list that matches no constructor
parameter lists, this error is raised. This error is the same as BU0057 but
applies specifically to constructors.

For example:

```
class MyClass {
    MyClass(int myInt) { }
}

MyClass myClass = new MyClass("test"); // Not allowed, no constructor for `MyClass` takes in a string argument
MyClass myClass = new MyClass(3); // Allowed
```
$BU0088
Modifiers are not always applicable to certain items. Such as a static method
outside of a class, a static struct in any context, etc. If a modifier is not
valid to a certain item this error is raised.
$BU0089
Static members do not rely on instance information, and for that reason it is
unnecessary and not allowed to access a static member through an instance.

For example:

```
class MyClass {
    static void MyMethod() { }
}

MyClass myInstance = new MyClass();

myInstance.MyMethod(); // Not allowed, attempting to access static member `MyMethod` through the instance `myInstance`
MyClass.MyMethod(); // Allowed
```
$BU0090
Non-static members rely on instance information, and for that reason cannot be
called statically.

For example:

```
class MyClass {
    void MyMethod() { }
}

MyClass.MyMethod(); // Not allowed, attempting to call non-static member `MyMethod` without an object reference

MyClass myInstance = new MyClass();
myInstance.MyMethod(); // Allowed
```
$BU9000
Inside a global scope without a `Main` method, the compiler will run the
file top-down instead. Return statements are allowed in this case, however, it
is currently unsupported to return a value in this case.

For example:

```
if (2 == 2)
    return; // This is allowed
else
    return 3; // This is not allowed
```
$BU0091
Fields cannot be initialized when they are declared in structures. This is to
keep structures functionally primitive, as they should only be used in low-level
contexts when they are necessary anyways.

For example:

```
struct MyStruct {
    int myField = 3; // Not allowed
}
```
$BU0092
There can only be one entry point, and because the compiler treats functions
named `Main` as an entry point, this error is raised if it finds multiple
functions named `Main`.

For example:

```
void Main() { }

void Main(int! argc, string[]! argv) { } // Not allowed, `Main` entry point already declared
```

```
void Main() { } // Allowed
```
$BU0093
Attributes are not valid for global statements. If any attributes are attached
to a global statement this error is raised.

Example here will be updated, but currently there are not attributes.
$BU0094
Some items require template arguments, while others do not. If an item without
template arguments is referenced but template arguments are supplied, this error
is raised.

For example:

```
class MyClass{ }

var myInstance = new MyClass<3>(); // Not allowed, `MyClass` does not expect the template argument `3`
var myInstance = new MyClass(); // Allowed
```
$BU0095
Passed template arguments must be compile-time constants because of the nature
of templates. If a non-constant value is desired to be passed instead, use
constructor arguments instead.

For example:

```
class MyClass<int templateParam> { }

var myInt = 3;
var myInstance = new MyClass<myInt>(); // Not allowed, `myInt` is not a compile-time constant
var myInstance = new MyClass<3>(); // Allowed
```
$BU0096
References point to other established objects in memory, and hence cannot
reference expressions that do not represent objects.

For example:

```
var myRef = ref 3; // Not allowed, `3` is not an object in memory that can be referenced

var myInt = 3;
var myRef = ref myInt; // Allowed
```
$BU0097
Some expressions are not allowed as expression statements as they perform no
action. If a type is used as an expression statement, this error is raised.

For example:

```
class MyClass { }
MyClass; // Not allowed, performs no action (dead code)
```
$BU0098
Static classes only contain static members. Because of this, you cannot create
an instance of a static class. And because instances are never created, no
constructors are ever called, making them dead code.

For example:

```
static class MyClass {
    MyClass() { } // Not allowed, constructor within a static class
}
```
$BU0099
Static classes cannot have instances, so a variable (an instance) cannot be of
a static type.

For example:

```
static class MyClass { }

MyClass myVar; // Not allowed, `MyClass` is a static type
```
$BU0100
Static classes cannot have instances.

For example:

```
static class MyClass { }

var myVar = new MyClass(); // Not allowed, cannot create an instance of static class `MyClass`
```
$BU0101
Static members are accessed without an instance, while constant members still
are. Because of this mismatch, a member cannot be marked as both static and
const.

For example:

```
class MyClass {
    static const void MyMethod() { } // Not allowed, marked as both `static` and `const`
    const void MyMethod() { } // Allowed
    static void MyMethod() { } // Allowed
}
```
$BU0102
Marking a method as constant means it cannot modify instance members.

For example:

```
class MyClass {
    int myField = 3;

    const void MyMethod() {
        myField++; // Not allowed, modifying instance member `myField` in method marked `const`
    }
}
```
$BU0103
Marking a method as constant means it cannot modify instance members. To ensure
this, methods marked as constant cannot mark other methods within the same class
that are not also marked as constant.

For example:

```
class MyClass {
    int myField = 3;

    void MyMethod() {
        myField++;
    }

    const void MyConstMethod() {
        MyMethod(); // Not allowed, `MyMethod` is not marked as constant so it cannot be called in this context
    }
}
```
$BU0104
A constant cannot call methods on itself that are not marked as constant.

For example:

```
class MyClass {
    int myField = 3;

    void MyMethod() {
        myField++;
    }
}

const myConst = new MyClass();
myConst.MyMethod(); // Not allowed, `MyMethod` is not marked as constant
```
$BU9001
Assembling natively is currently unsupported. If it is requested to assemble
natively, the compilation will not raise an error but rather ignore the request.

Compiling with .NET integration is the priority, so compiling natively will
likely be unsupported for many versions.
$BU9002
Linking natively is currently unsupported. If it is requested to link natively,
the compilation will not raise an error but rather ignore the request.

Compiling with .NET integration is the priority, so compiling natively will
likely be unsupported for many versions.
$BU9003
Compiling natively is currently unsupported. If it is requested to compile
natively, this error is raised.

Compiling with .NET integration is the priority, so compiling natively will
likely be unsupported for many versions.
$BU9004
Compiling with .NET integration is currently unsupported.
